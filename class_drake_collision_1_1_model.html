<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Drake: Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_drake_collision_1_1_model.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_drake_collision_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Model Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_model_8h_source.html">drake/systems/plants/collision/Model.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Model:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model__inherit__graph.png" border="0" usemap="#_model_inherit__map" alt="Inheritance graph"/></div>
<map name="_model_inherit__map" id="_model_inherit__map">
<area shape="rect" id="node2" href="class_drake_collision_1_1_bullet_model.html" title="BulletModel" alt="" coords="5,80,96,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Model:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model__coll__graph.png" border="0" usemap="#_model_coll__map" alt="Collaboration graph"/></div>
<map name="_model_coll__map" id="_model_coll__map">
<area shape="rect" id="node4" href="class_drake_collision_1_1_element.html" title="Element" alt="" coords="59,5,129,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30c57abda5ed227c85b50007cee876db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a30c57abda5ed227c85b50007cee876db">Model</a> ()</td></tr>
<tr class="separator:a30c57abda5ed227c85b50007cee876db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79d94fcfaad68d16129d1c8e6be1bb8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#aa79d94fcfaad68d16129d1c8e6be1bb8">~Model</a> ()</td></tr>
<tr class="separator:aa79d94fcfaad68d16129d1c8e6be1bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca54374a8799297642973c6789013851"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#aca54374a8799297642973c6789013851">addElement</a> (const <a class="el" href="class_drake_collision_1_1_element.html">Element</a> &amp;element)</td></tr>
<tr class="memdesc:aca54374a8799297642973c6789013851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a collision element to this model.  <a href="#aca54374a8799297642973c6789013851">More...</a><br /></td></tr>
<tr class="separator:aca54374a8799297642973c6789013851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ad0a8d1d1b3ea9021fb4cfb546220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a3b1ad0a8d1d1b3ea9021fb4cfb546220">removeElement</a> (const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> &amp;id)</td></tr>
<tr class="separator:a3b1ad0a8d1d1b3ea9021fb4cfb546220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558385553d80a02055040c0c0ba28a85"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_drake_collision_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a558385553d80a02055040c0c0ba28a85">readElement</a> (<a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> id) const </td></tr>
<tr class="memdesc:a558385553d80a02055040c0c0ba28a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only pointer to a collision element in this model.  <a href="#a558385553d80a02055040c0c0ba28a85">More...</a><br /></td></tr>
<tr class="separator:a558385553d80a02055040c0c0ba28a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3348d31dfa26b8059d450a06fdcca2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#acc3348d31dfa26b8059d450a06fdcca2">getTerrainContactPoints</a> (<a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> id0, Eigen::Matrix3Xd &amp;terrain_points)</td></tr>
<tr class="separator:acc3348d31dfa26b8059d450a06fdcca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf0cf5d444b31b15d60df324979e870"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a9cf0cf5d444b31b15d60df324979e870">updateModel</a> ()=0</td></tr>
<tr class="memdesc:a9cf0cf5d444b31b15d60df324979e870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any operations needed to bring the model up-to-date after making changes to its collision elements.  <a href="#a9cf0cf5d444b31b15d60df324979e870">More...</a><br /></td></tr>
<tr class="separator:a9cf0cf5d444b31b15d60df324979e870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757f70d502a9191eca98949f5f3a8312"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a757f70d502a9191eca98949f5f3a8312">updateElementWorldTransform</a> (const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> id, const Eigen::Isometry3d &amp;T_local_to_world)</td></tr>
<tr class="memdesc:a757f70d502a9191eca98949f5f3a8312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the element-to-world transform of a specified collision element.  <a href="#a757f70d502a9191eca98949f5f3a8312">More...</a><br /></td></tr>
<tr class="separator:a757f70d502a9191eca98949f5f3a8312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a45c34c5f16b7296ecbfccc3f40c63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#af0a45c34c5f16b7296ecbfccc3f40c63">closestPointsAllToAll</a> (const std::vector&lt; <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> &gt; &amp;ids_to_check, const bool use_margins, std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;closest_points)=0</td></tr>
<tr class="memdesc:af0a45c34c5f16b7296ecbfccc3f40c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the points of closest approach between all eligible pairs of collision elements drawn from a specified set of elements.  <a href="#af0a45c34c5f16b7296ecbfccc3f40c63">More...</a><br /></td></tr>
<tr class="separator:af0a45c34c5f16b7296ecbfccc3f40c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b364391708cf7b912939f791a792832"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a3b364391708cf7b912939f791a792832">ComputeMaximumDepthCollisionPoints</a> (const bool use_margins, std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;closest_points)=0</td></tr>
<tr class="memdesc:a3b364391708cf7b912939f791a792832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of closest approach between collision elements that are in contact.  <a href="#a3b364391708cf7b912939f791a792832">More...</a><br /></td></tr>
<tr class="separator:a3b364391708cf7b912939f791a792832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaff2d2561b2baec41836922ab39bde"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#abbaff2d2561b2baec41836922ab39bde">closestPointsPairwise</a> (const std::vector&lt; <a class="el" href="namespace_drake_collision.html#addbd6a728eaa01f6de25656dfea0e6c2">ElementIdPair</a> &gt; &amp;id_pairs, const bool use_margins, std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;closest_points)=0</td></tr>
<tr class="memdesc:abbaff2d2561b2baec41836922ab39bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the points of closest approach between specified pairs of collision elements.  <a href="#abbaff2d2561b2baec41836922ab39bde">More...</a><br /></td></tr>
<tr class="separator:abbaff2d2561b2baec41836922ab39bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c7b1640ab155acffb23e9cfca48f70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a95c7b1640ab155acffb23e9cfca48f70">ClearCachedResults</a> (bool use_margins)=0</td></tr>
<tr class="memdesc:a95c7b1640ab155acffb23e9cfca48f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears possibly cached results so that a fresh computation can be performed.  <a href="#a95c7b1640ab155acffb23e9cfca48f70">More...</a><br /></td></tr>
<tr class="separator:a95c7b1640ab155acffb23e9cfca48f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb11c23d1bf0529a25dad7672a088ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#acfb11c23d1bf0529a25dad7672a088ca">collisionDetectFromPoints</a> (const Eigen::Matrix3Xd &amp;points, bool use_margins, std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;closest_points)=0</td></tr>
<tr class="memdesc:acfb11c23d1bf0529a25dad7672a088ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute closest distance from each point to any surface in the collision model utilizing Bullet's collision detection code.  <a href="#acfb11c23d1bf0529a25dad7672a088ca">More...</a><br /></td></tr>
<tr class="separator:acfb11c23d1bf0529a25dad7672a088ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eddb2ee94960f49a6abc9cda9e7a4a2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a9eddb2ee94960f49a6abc9cda9e7a4a2">potentialCollisionPoints</a> (bool use_margins)=0</td></tr>
<tr class="memdesc:a9eddb2ee94960f49a6abc9cda9e7a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the set of potential collision points for all eligible pairs of collision geometries in this model.  <a href="#a9eddb2ee94960f49a6abc9cda9e7a4a2">More...</a><br /></td></tr>
<tr class="separator:a9eddb2ee94960f49a6abc9cda9e7a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2188a058080c13969428c38d88805ac7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a2188a058080c13969428c38d88805ac7">collidingPoints</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;input_points, <a class="el" href="classdouble.html">double</a> collision_threshold)=0</td></tr>
<tr class="memdesc:a2188a058080c13969428c38d88805ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of points in world coordinates, returns the indices of those points within a specified distance of any collision geometry in the model.  <a href="#a2188a058080c13969428c38d88805ac7">More...</a><br /></td></tr>
<tr class="separator:a2188a058080c13969428c38d88805ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9d82e91344c4c06f33af6d2cc0378"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a41d9d82e91344c4c06f33af6d2cc0378">collidingPointsCheckOnly</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;input_points, <a class="el" href="classdouble.html">double</a> collision_threshold)=0</td></tr>
<tr class="memdesc:a41d9d82e91344c4c06f33af6d2cc0378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if any of the points supplied in input_points collides with any part of the model within a given threshold.  <a href="#a41d9d82e91344c4c06f33af6d2cc0378">More...</a><br /></td></tr>
<tr class="separator:a41d9d82e91344c4c06f33af6d2cc0378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a08647f642e9afdc649903538382e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a67a08647f642e9afdc649903538382e6">collisionRaycast</a> (const Eigen::Matrix3Xd &amp;origin, const Eigen::Matrix3Xd &amp;ray_endpoint, bool use_margins, Eigen::VectorXd &amp;distances, Eigen::Matrix3Xd &amp;normals)=0</td></tr>
<tr class="memdesc:a67a08647f642e9afdc649903538382e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs raycasting collision detecting (like a LIDAR / laser rangefinder)  <a href="#a67a08647f642e9afdc649903538382e6">More...</a><br /></td></tr>
<tr class="separator:a67a08647f642e9afdc649903538382e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6583f213ebd0069649070c62760f3095"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a6583f213ebd0069649070c62760f3095">transformCollisionFrame</a> (const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">DrakeCollision::ElementId</a> &amp;eid, const Eigen::Isometry3d &amp;transform_body_to_joint)</td></tr>
<tr class="memdesc:a6583f213ebd0069649070c62760f3095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a collision element's local transform to be relative to a joint's frame rather than a link's frame.  <a href="#a6583f213ebd0069649070c62760f3095">More...</a><br /></td></tr>
<tr class="separator:a6583f213ebd0069649070c62760f3095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5f89be6ecb6014f602b4c928373fe1fa"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>, std::unique_ptr&lt; <a class="el" href="class_drake_collision_1_1_element.html">Element</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a5f89be6ecb6014f602b4c928373fe1fa">elements</a></td></tr>
<tr class="separator:a5f89be6ecb6014f602b4c928373fe1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a57b9f8bf0fb0afb8f6e4fbe41d806c99"><td class="memItemLeft" align="right" valign="top">DRAKECOLLISION_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drake_collision_1_1_model.html#a57b9f8bf0fb0afb8f6e4fbe41d806c99">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_drake_collision_1_1_model.html">Model</a> &amp;)</td></tr>
<tr class="memdesc:a57b9f8bf0fb0afb8f6e4fbe41d806c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A toString method for this class.  <a href="#a57b9f8bf0fb0afb8f6e4fbe41d806c99">More...</a><br /></td></tr>
<tr class="separator:a57b9f8bf0fb0afb8f6e4fbe41d806c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a30c57abda5ed227c85b50007cee876db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_drake_collision_1_1_model.html">Model</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa79d94fcfaad68d16129d1c8e6be1bb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="class_drake_collision_1_1_model.html">Model</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model_aa79d94fcfaad68d16129d1c8e6be1bb8_cgraph.png" border="0" usemap="#class_drake_collision_1_1_model_aa79d94fcfaad68d16129d1c8e6be1bb8_cgraph" alt=""/></div>
<map name="class_drake_collision_1_1_model_aa79d94fcfaad68d16129d1c8e6be1bb8_cgraph" id="class_drake_collision_1_1_model_aa79d94fcfaad68d16129d1c8e6be1bb8_cgraph">
<area shape="rect" id="node2" href="namespace_drake_collision.html#a3d0c6094717cc7811d730c17eb912a24" title="DrakeCollision::closestPoints\lAllToAll" alt="" coords="119,5,311,47"/>
<area shape="rect" id="node3" href="namespace_drake_collision.html#a9085531634d51f849a4917335e588438" title="DrakeCollision::closestPoints\lPairwise" alt="" coords="119,71,311,112"/>
<area shape="rect" id="node4" href="namespace_drake_collision.html#acdf2797372e685a58cc51072edfdf5a6" title="DrakeCollision::operator\&lt;\&lt;" alt="" coords="127,137,303,163"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aca54374a8799297642973c6789013851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> addElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_drake_collision_1_1_element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a collision element to this model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the collision element to be added to this model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ElementId that uniquely identifies the added element within this model </dd></dl>

<p>Reimplemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a20695d3a1510bdf44cf470666d84ccc1">BulletModel</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_cgraph.png" border="0" usemap="#class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_cgraph" alt=""/></div>
<map name="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_cgraph" id="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_cgraph">
<area shape="rect" id="node2" href="class_drake_collision_1_1_element.html#a6c717aacfd45cb9f2c235788eadd9db6" title="DrakeCollision::Element\l::clone" alt="" coords="144,5,305,47"/>
<area shape="rect" id="node3" href="class_drake_collision_1_1_element.html#a82f6e1ddea08d4963e955607b262d4e2" title="DrakeCollision::Element\l::Element" alt="" coords="353,5,515,47"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_icgraph.png" border="0" usemap="#class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_icgraph" alt=""/></div>
<map name="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_icgraph" id="class_drake_collision_1_1_model_aca54374a8799297642973c6789013851_icgraph">
<area shape="rect" id="node2" href="class_drake_collision_1_1_bullet_model.html#a20695d3a1510bdf44cf470666d84ccc1" title="Add a collision element to this model. " alt="" coords="144,5,325,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a95c7b1640ab155acffb23e9cfca48f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClearCachedResults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_margins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears possibly cached results so that a fresh computation can be performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_margins[in]</td><td>If <code>true</code>, the cache of the model with margins is cleared. If <code>false</code>, the cache of the model without margins is cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>Depending on the implementation, the collision model may cache results on each dispatch. For instance, Bullet uses cached results to warm-start its LCP solvers.</p>
<p>Clearing cached results allows the collision model to perform a fresh computation without any coupling with previous history.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="model__test_8cc.html">drake/systems/plants/collision/test/model_test.cc</a>. </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a5307a26d48d42be6cf27b92c7f5be99f">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="af0a45c34c5f16b7296ecbfccc3f40c63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool closestPointsAllToAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids_to_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_margins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the points of closest approach between all eligible pairs of collision elements drawn from a specified set of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ids_to_check</td><td>the vector of ElementId for which the all-to-all collision detection should be performed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_margins</td><td>flag indicating whether or not to use the version of this model with collision margins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_points</td><td>reference to a vector of <a class="el" href="struct_drake_collision_1_1_point_pair.html" title="Structure containing the results of a collision query. ">PointPair</a> objects that contains the closest point information after this method is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this method ran successfully </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#aefd874bca61a92a70e4e3910396b38a4">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="abbaff2d2561b2baec41836922ab39bde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool closestPointsPairwise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_drake_collision.html#addbd6a728eaa01f6de25656dfea0e6c2">ElementIdPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>id_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_margins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the points of closest approach between specified pairs of collision elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">id_pairs</td><td>vector of ElementIdPair specifying which pairs of elements to consider </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_margins</td><td>flag indicating whether or not to use the version of this model with collision margins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_points</td><td>reference to a vector of <a class="el" href="struct_drake_collision_1_1_point_pair.html" title="Structure containing the results of a collision query. ">PointPair</a> objects that contains the closest point information after this method is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this method ran successfully </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a8c4e7aa0dafb075e4b77d06ced6febba">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="a2188a058080c13969428c38d88805ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;size_t&gt; collidingPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>collision_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector of points in world coordinates, returns the indices of those points within a specified distance of any collision geometry in the model. </p>
<p>In other words, this method tests if a sphere of radius collision_threshold located at input_points[i] collides with any part of the model. The result is returned as a vector of indexes in input_points that do collide with the model. Points are not checked against one another but only against the existing model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_points</td><td>The list of points to check for collisions against the model. </td></tr>
    <tr><td class="paramname">collision_threshold</td><td>The radius of a control sphere around each point used to check for collisions with the model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with indexes in input_points of all those points that do collide with the model within the specified threshold.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>systems/plants/test/collidingPointsTest.m for a Matlab test. </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#ab9adab3bc16807dc34262aa62dfac0d8">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="a41d9d82e91344c4c06f33af6d2cc0378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool collidingPointsCheckOnly </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>collision_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if any of the points supplied in input_points collides with any part of the model within a given threshold. </p>
<p>In other words, this method tests if any of the spheres of radius collision_threshold located at input_points[i] collides with any part of the model. This method returns as soon as any of these spheres collides with the model. Points are not checked against one another but only against the existing model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_points</td><td>The list of points to check for collisions against the model. </td></tr>
    <tr><td class="paramname">collision_threshold</td><td>The radius of a control sphere around each point used to check for collisions with the model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any of the points positively checks for collision. <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a092db3782a7368249938084aee83c35f">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="acfb11c23d1bf0529a25dad7672a088ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void collisionDetectFromPoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_margins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute closest distance from each point to any surface in the collision model utilizing Bullet's collision detection code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">points</td><td>Matrix of points computing distance from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_margins</td><td>flag indicating whether or not to use the version of this model with collision margins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_points</td><td>a vector of <a class="el" href="struct_drake_collision_1_1_point_pair.html" title="Structure containing the results of a collision query. ">PointPair</a> objects containing the signed distances </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a7b5c2169942936556926b4882d6e51c5">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="a67a08647f642e9afdc649903538382e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool collisionRaycast </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>ray_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_margins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs raycasting collision detecting (like a LIDAR / laser rangefinder) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">origin</td><td>3 x N matrix in which each column specifies the position of a ray's origin in world coordinates. if origin is 3x1, then the same origin is used for all raycasts </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ray_endpoint</td><td>3 x N matrix in which each column specifies a second point on the corresponding ray </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_margins</td><td>flag indicating whether or not to use the version of this model with collision margins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>to the first collision, or -1 on no collision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this method ran successfully </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a6f461dfecf3baf0607d81861a6f1930e">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="a3b364391708cf7b912939f791a792832"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ComputeMaximumDepthCollisionPoints </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_margins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the point of closest approach between collision elements that are in contact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_margins</td><td>If <code>true</code> the model uses the representation with margins. If <code>false</code>, the representation without margins is used instead.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closest_points</td><td>reference to a vector of <a class="el" href="struct_drake_collision_1_1_point_pair.html" title="Structure containing the results of a collision query. ">PointPair</a> objects that contains the closest point information after this method is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this method ran successfully and <code>false</code> otherwise. </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a65107b2cf0dca012fd488e64fed49af4">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="acc3348d31dfa26b8059d450a06fdcca2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getTerrainContactPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>&#160;</td>
          <td class="paramname"><em>id0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>terrain_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model_acc3348d31dfa26b8059d450a06fdcca2_cgraph.png" border="0" usemap="#class_drake_collision_1_1_model_acc3348d31dfa26b8059d450a06fdcca2_cgraph" alt=""/></div>
<map name="class_drake_collision_1_1_model_acc3348d31dfa26b8059d450a06fdcca2_cgraph" id="class_drake_collision_1_1_model_acc3348d31dfa26b8059d450a06fdcca2_cgraph">
<area shape="rect" id="node2" href="class_drake_shapes_1_1_element.html#a38d95ad0a627e4ce1d9a4e0e25f5f49a" title="DrakeShapes::Element\l::getTerrainContactPoints" alt="" coords="215,5,384,47"/>
<area shape="rect" id="node3" href="class_drake_shapes_1_1_element.html#afb644dac4799d26a47e1c3625ded7e64" title="DrakeShapes::Element\l::hasGeometry" alt="" coords="432,5,588,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9eddb2ee94960f49a6abc9cda9e7a4a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="struct_drake_collision_1_1_point_pair.html">PointPair</a>&gt; potentialCollisionPoints </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_margins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the set of potential collision points for all eligible pairs of collision geometries in this model. </p>
<p>This includes the points of closest approach, but may also include additional points that are "close" to being in contact. This can be useful when simulating scenarios in which two collision elements have more than one point of contact. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_margins</td><td>flag indicating whether or not to use the version of this model with collision margins </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="struct_drake_collision_1_1_point_pair.html" title="Structure containing the results of a collision query. ">PointPair</a> objects containing the potential collision points </dd></dl>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a7baa2fa8e78e823d6a37f42e0f311138">BulletModel</a>.</p>

</div>
</div>
<a class="anchor" id="a558385553d80a02055040c0c0ba28a85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_drake_collision_1_1_element.html">Element</a> * readElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a read-only pointer to a collision element in this model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an ElementId corresponding to the desired collision element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a read-only pointer to the collision element corresponding to the given id or nullptr if no such collision element is present in the model. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1ad0a8d1d1b3ea9021fb4cfb546220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool removeElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6583f213ebd0069649070c62760f3095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool transformCollisionFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">DrakeCollision::ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>eid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>transform_body_to_joint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies a collision element's local transform to be relative to a joint's frame rather than a link's frame. </p>
<p>This is necessary because <a class="el" href="namespace_drake.html" title="NOTE: The contents of this class are for the most part direct ports of drake/systems/plants//inverseK...">Drake</a> requires that link frames by defined by their parent joint frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eid</td><td>The ID of the collision element to update. </td></tr>
    <tr><td class="paramname">transform_body_to_joint</td><td>The transform from the collision element's link's frame to the joint's coordinate frame. </td></tr>
    <tr><td class="paramname">true</td><td>if the collision element was successfully updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a757f70d502a9191eca98949f5f3a8312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool updateElementWorldTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>T_local_to_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the element-to-world transform of a specified collision element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an ElementId corresponding to the element to be updated </td></tr>
    <tr><td class="paramname">T_local_to_world</td><td>the new value for the element-to-world transform </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a4564cf28d78f0a6282fd677e295ba06b">BulletModel</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_drake_collision_1_1_model_a757f70d502a9191eca98949f5f3a8312_icgraph.png" border="0" usemap="#class_drake_collision_1_1_model_a757f70d502a9191eca98949f5f3a8312_icgraph" alt=""/></div>
<map name="class_drake_collision_1_1_model_a757f70d502a9191eca98949f5f3a8312_icgraph" id="class_drake_collision_1_1_model_a757f70d502a9191eca98949f5f3a8312_icgraph">
<area shape="rect" id="node2" href="class_drake_collision_1_1_bullet_model.html#a4564cf28d78f0a6282fd677e295ba06b" title="Change the element&#45;to&#45;world transform of a specified collision element. " alt="" coords="253,5,461,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9cf0cf5d444b31b15d60df324979e870"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any operations needed to bring the model up-to-date after making changes to its collision elements. </p>

<p>Implemented in <a class="el" href="class_drake_collision_1_1_bullet_model.html#a495d86ed24955a38c6e09e999810bbec">BulletModel</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a57b9f8bf0fb0afb8f6e4fbe41d806c99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKECOLLISION_EXPORT std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_drake_collision_1_1_model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A toString method for this class. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5f89be6ecb6014f602b4c928373fe1fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="namespace_drake_collision.html#abedcf22a55257b04e6b7a12700ae4c22">ElementId</a>, std::unique_ptr&lt;<a class="el" href="class_drake_collision_1_1_element.html">Element</a>&gt; &gt; elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/systems/plants/collision/<a class="el" href="_model_8h_source.html">Model.h</a></li>
<li>drake/systems/plants/collision/<a class="el" href="_model_8cpp.html">Model.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_drake_collision.html">DrakeCollision</a></li><li class="navelem"><a class="el" href="class_drake_collision_1_1_model.html">Model</a></li>
    <li class="footer">Generated on Sun Jul 17 2016 12:12:14 for Drake by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
